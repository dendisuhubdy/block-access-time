{"name":"Monero Examples","tagline":"block-access-time","body":"# Measure block access time\r\nWhile working on another example, I've noticed that access time to some\r\nmonero blocks, especially early ones, using `Blockchain::get_block_by_hash`,\r\nis very long. Thus, I wanted check this for all blocks  blockchain.\r\n\r\nAs a result of this, this example was created showing how to loop through all\r\nblocks in lmdb blockchain, and save some basic information from the blocks,\r\nas well as measure access time, into an output csv file.\r\n\r\n## Pre-requisites\r\n\r\nEverything here was done and tested on\r\nUbuntu 14.04 x86_64 and Ubuntu 15.10 x86_64.\r\n\r\nMonero source code compilation and setup are same as [here](http://moneroexamples.github.io/access-blockchain-in-cpp/).\r\n\r\n\r\n## C++: main.cpp\r\n\r\n```c++\r\nint main(int ac, const char* av[]) {\r\n\r\n    // get command line options\r\n    xmreg::CmdLineOptions opts {ac, av};\r\n\r\n    auto help_opt = opts.get_option<bool>(\"help\");\r\n\r\n    // if help was chosen, display help text and finish\r\n    if (*help_opt)\r\n    {\r\n        return 0;\r\n    }\r\n\r\n    // get other options\r\n    auto start_height_opt = opts.get_option<size_t>(\"start-height\");\r\n    auto out_csv_file_opt = opts.get_option<string>(\"out-csv-file\");\r\n    auto bc_path_opt      = opts.get_option<string>(\"bc-path\");\r\n\r\n\r\n    // default path to monero folder\r\n    // on linux this is /home/<username>/.bitmonero\r\n    string default_monero_dir = tools::get_default_data_dir();\r\n\r\n    // the default folder of the lmdb blockchain database\r\n    // is therefore as follows\r\n    string default_lmdb_dir   = default_monero_dir + \"/lmdb\";\r\n\r\n    // get the program command line options, or\r\n    // some default values for quick check\r\n    size_t start_height  = start_height_opt ? *start_height_opt : 0;\r\n    string out_csv_file  = out_csv_file_opt ? *out_csv_file_opt : \"/tmp/block_access_time.csv\";\r\n    path blockchain_path = bc_path_opt ? path(*bc_path_opt) : path(default_lmdb_dir);\r\n\r\n\r\n    if (!is_directory(blockchain_path))\r\n    {\r\n        cerr << \"Given path \\\"\" << blockchain_path   << \"\\\" \"\r\n             << \"is not a folder or does not exist\" << \" \"\r\n             << endl;\r\n        return 1;\r\n    }\r\n\r\n    blockchain_path = xmreg::remove_trailing_path_separator(blockchain_path);\r\n\r\n    cout << \"Blockchain path: \" << blockchain_path << endl;\r\n\r\n    // enable basic monero log output\r\n    uint32_t log_level = 0;\r\n    epee::log_space::get_set_log_detalisation_level(true, log_level);\r\n    epee::log_space::log_singletone::add_logger(LOGGER_CONSOLE, NULL, NULL);\r\n\r\n\r\n    // create instance of our MicroCore\r\n    xmreg::MicroCore mcore;\r\n\r\n    // initialize the core using the blockchain path\r\n    if (!mcore.init(blockchain_path.string()))\r\n    {\r\n        cerr << \"Error accessing blockchain.\" << endl;\r\n        return 1;\r\n    }\r\n\r\n    // get the highlevel cryptonote::Blockchain object to interact\r\n    // with the blockchain lmdb database\r\n    cryptonote::Blockchain& core_storage = mcore.get_core();\r\n\r\n    // get the current blockchain height. Just to check\r\n    // if it reads ok.\r\n    uint64_t height = core_storage.get_current_blockchain_height();\r\n\r\n    if (start_height > height)\r\n    {\r\n        cerr << \"Given height is greater than blockchain height\" << endl;\r\n        return 1;\r\n    }\r\n\r\n\r\n    cout << \"Current blockchain height: \" << height << endl;\r\n\r\n\r\n    // output csv file\r\n    csv::ofstream csv_os {out_csv_file.c_str()};\r\n\r\n    if (!csv_os.is_open())\r\n    {\r\n        cerr << \"Cant open file: \" << out_csv_file << endl;\r\n        return 1;\r\n    }\r\n\r\n    cout << \"Csv file: \" <<  out_csv_file << \" opened for wrting results.\" << endl;\r\n\r\n    // write csv header\r\n    csv_os << \"Height\" << \"Timestamp\" << \"Access_time\" << \"Size\"\r\n           << \"Hash\" << \"No_tx\" << \"Reward\" << \"Dificulty\" << NEWLINE;\r\n\r\n    // show command line output for everth i-th block\r\n    const uint64_t EVERY_ith_BLOCK {2000};\r\n\r\n    for (uint64_t i = start_height; i < height; ++i) {\r\n\r\n        // show every nth output, just to give\r\n        // a console some break\r\n        if (i % EVERY_ith_BLOCK == 0)\r\n            cout << \"Analysing block \" << i <<  \"/\" << height << endl;\r\n\r\n\r\n\r\n        crypto::hash block_id;\r\n\r\n        try\r\n        {\r\n            // get block hash to be used to for the search\r\n            // in the next step\r\n            block_id = core_storage.get_block_id_by_height(i);\r\n        }\r\n        catch (const exception& e)\r\n        {\r\n            cerr << e.what() << endl;\r\n            continue;\r\n        }\r\n\r\n\r\n        cryptonote::block blk;\r\n\r\n        try\r\n        {\r\n            // measure time of accessing ith block from the blockchain\r\n            auto start = chrono::system_clock::now();\r\n            //blk = core_storage.get_db().get_block_from_height(i); // <-- alternative, faster\r\n            core_storage.get_block_by_hash(block_id, blk);\r\n            auto duration = chrono::duration_cast<chrono::nanoseconds>(chrono::system_clock::now() - start);\r\n\r\n            // get block size\r\n            size_t blk_size = core_storage.get_db().get_block_size(i);\r\n\r\n            if (i % EVERY_ith_BLOCK == 0)\r\n                cout << \" - \" << \"access time: \" << duration.count() << \" ns.\" << endl;\r\n\r\n            // save measured data to the output csv file\r\n            csv_os << i << xmreg::timestamp_to_str(blk.timestamp)\r\n                   << duration.count() << blk_size\r\n                   << core_storage.get_block_id_by_height(i)\r\n                   << blk.tx_hashes.size()\r\n                   << cryptonote::print_money(mcore.get_block_reward(blk))\r\n                   << core_storage.get_db().get_block_difficulty(i)\r\n                   << NEWLINE;\r\n        }\r\n        catch (const exception& e)\r\n        {\r\n            cerr << e.what() << endl;\r\n            continue;\r\n        }\r\n\r\n\r\n    } // for (uint64_t i = 0; i < height; ++i)\r\n\r\n\r\n    // colose the output csv file\r\n    csv_os.flush();\r\n    csv_os.close();\r\n\r\n    cout << \"\\nCsv saved as: \" << out_csv_file << endl;\r\n\r\n    cout << \"\\nEnd of program.\" << endl;\r\n\r\n    return 0;\r\n}```\r\n\r\n## Results\r\n\r\n- The resulted csv file can be seen [here](https://mega.nz/#!P4cWWTLK!Eb5m4q4f5Tx-5p5FNMwF7cv0ckvPTX5Hy5fqGn7VFm4).\r\n\r\n- The plot of log of block access time against block number is [here](http://i.imgur.com/2xmAF0c.png).\r\n\r\nFrom the csv and data, it can be seen that there is very large\r\nconcentration of very long times up to block of about 100k. This\r\nresults in very slow recovery of your deterministic wallet, when\r\nthe blocks in this range are being scanned for your transactions.\r\n\r\n\r\n## Compile this example\r\nThe dependencies are same as those for Monero, so I assume Monero compiles\r\ncorrectly. If so then to download and compile this example, the following\r\nsteps can be executed:\r\n\r\n```bash\r\n# download the source code\r\ngit clone https://github.com/moneroexamples/block-access-time\r\n\r\n# enter the downloaded sourced code folder\r\ncd block-access-time\r\n\r\n# create the makefile\r\ncmake .\r\n\r\n# compile\r\nmake\r\n```\r\n\r\nAfter this, `blkaccesstime` executable file should be present in access-blockchain-in-cpp\r\nfolder. How to use it, can be seen in the above example outputs.\r\n\r\n\r\n## How can you help?\r\n\r\nConstructive criticism, code and website edits are always good. They can be made through github.\r\n\r\nSome Monero are also welcome:\r\n```\r\n48daf1rG3hE1Txapcsxh6WXNe9MLNKtu7W7tKTivtSoVLHErYzvdcpea2nSTgGkz66RFP4GKVAsTV14v6G3oddBTHfxP6tU\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}